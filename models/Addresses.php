<?php

namespace app\models;

use function GuzzleHttp\Psr7\str;
use Yii;
use yii\helpers\Url;

/**
 * This is the model class for table "{{%_addresses}}".
 *
 * @property integer $id
 * @property double $coords_x
 * @property double $coords_y
 * @property string $address
 * @property string $street
 * @property string $house
 * @property string $hull
 * @property integer $floorcount
 * @property string $address_string_variants
 * @property integer $year
 * @property integer $house_type
 * @property string $district
 * @property string $locality
 * @property integer $relative_id
 * @property string $precision_yandex
 * @property string $url
 * @property string $tags_id
 */
class Addresses extends \yii\db\ActiveRecord
{
    /**
     * @inheritdoc
     */

    const STATUSES = [
        0 => 'NEW',
        1 => 'UNMODERATED',
        2 => 'MODERATED'
    ];
    private static $tablePrefix;

    public static function tableName()
    {
        if (self::$tablePrefix) {
            return self::$tablePrefix . '_addresses';
        } else {
            // Если префикс не устанавливался - стучимся за ним в сессию
            $session = Yii::$app->session;
            return $session->get('city_module') . "_addresses";
        }
    }

    public static function setTablePrefix($prefix)
    {
        self::$tablePrefix = $prefix;
    }

    public function formName()
    {
        return '';
    }

    /**
     * @inheritdoc
     */
    public function rules()
    {
        return [
            [['coords_x', 'coords_y'], 'number'],
            [['house_type', 'floorcount', 'year', 'fullfilled', 'house'], 'integer'],
            [['address_string_variants','AdministrativeAreaName'], 'string'],
            [['address', 'street', 'url'], 'string', 'max' => 400],
            [['precision_yandex', 'hull'], 'string', 'max' => 10],
            [['district','AdministrativeAreaName'], 'string', 'max' => 100],
            [['locality'], 'string', 'max' => 100],
            [['tags_id'], 'string', 'max' => 256],
            [['street'], 'required']

        ];
    }

    public function beforeValidate()
    {
        $this->generateAddress();
        return parent::beforeValidate(); // TODO: Change the autogenerated stub
    }

    public function generateAddress($delimiter = '')
    {
       if ($delimiter) {
           $address = '';
           if ($this->street) $address .= $this->street;
           if ($this->house) $address .=  $delimiter . "" .  $this->house;
           if (($this->hull) and ($this->hull != '-'))  $address .= $delimiter . "" .  $this->hull;
           $this->address = $address;

       } else {
           $address = '';
           if ($this->street) $address .= $this->street;
           if ($this->house) $address .= ", " . $this->house;
           if (($this->hull) and ($this->hull != '-'))  $address .= "к" . $this->hull;
           $this->address = $address;
       }

        return $address;

    }
    public function getAddressString()
    {
        $address = '';
        if ($this->street) $address .= $this->street;
        if ($this->house) $address .= ", " . $this->house;
        if ($this->hull) $address .= "к" . $this->hull;
        $this->address = $address;
        return $address;

    }

    /**
     * @inheritdoc
     */
    public function attributeLabels()
    {
        return [
            'id' => 'ID',
            'coords_x' => 'координата х',
            'coords_y' => 'координата y',
            'address' => 'Адрес',
            'street' => 'Улица',
            'house' => 'дом',
            'hull' => 'корпус',
            'url' => 'url',
            'house_type' => 'тип дома',
            'floorcount' => 'этажность дома',
            'address_string_variants' => 'варианты названий адреса сериалтзованные в текст',
            'year' => 'год постройки',
            'precision_yandex' => 'precision',
            'district' => 'Район Города',
            'relative_id' => 'Дубликат',
            'locality' => 'Название населенного пункта',
            'fullfilled' => 'Заполненность адреса'
        ];
    }

    public static function getDistricts()
    {
        return Addresses::find()
            ->where(['AdministrativeAreaName' => 'Новгородская область'])
            ->select('district')
            ->distinct()
            ->all();
    }
   public static function getRegions()
    {
        return Addresses::find()
          //  ->where(['AdministrativeAreaName' => 'Новгородская область'])
            ->select('AdministrativeAreaName')
            ->distinct()
            ->all();
    }

    public static function getLocalities()
    {
        return Addresses::find()
            ->where(['AdministrativeAreaName' => 'Новгородская область'])
            ->select('locality')
            ->distinct()
            ->all();
    }

    public static function getStreets()
    {
        return Addresses::find()
            ->where(['AdministrativeAreaName' => 'Новгородская область'])
            ->select('street')
            ->distinct()
            ->all();
    }

    /**
     * @inheritdoc
     * @return AddressesQuery the active query used by this AR class.
     */
    public static function find()
    {
        return new AddressesQuery(get_called_class());
    }

    public function is_new_address($fullname)
    {

    }

    public function try_to_find_floorcount()
    {
        // ищем в истории где есть эта этажность
        $sale_history = SaleHistory::find()
            ->andWhere(['id_address' => $this->id])
            ->andWhere(['in', 'floorcount', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]])
            ->one();
        if (!empty($sale_history->id)) {
            // вставляем значение в таблицу адресов
            $UpdatedAddress = Addresses::findOne($this->id);
            echo "удалось прописать floorcount " . $UpdatedAddress->id . "  = " . $sale_history->floorcount;
            $UpdatedAddress->floorcount = $sale_history->floorcount;
            $UpdatedAddress->save();

        } else {
            // ищем в истории где есть эта этажность
            $sale_history = Sale::find()
                ->andWhere(['id_address' => $this->id])
                ->andWhere(['in', 'floorcount', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]])
                ->one();
            if (!empty($sale_history->id)) {
                // вставляем значение в таблицу адресов
                $UpdatedAddress = Addresses::findOne($this->id);
                echo "удалось прописать floorcount " . $UpdatedAddress->id . "  = " . $sale_history->floorcount;
                $UpdatedAddress->floorcount = $sale_history->floorcount;
                $UpdatedAddress->save();

            }

        }
    }
    // связь tags
//    public function getTags() {
//        return $this->hasMany(RealTags::className(), ['id_address_tag' => 'id'])->select('tag_id')->column();
//        // ->viaTable(Tags::tableName(),['id' => 'tag_id']);
//
//    }
    public function getTags()
    {

        return Tags::convertToArray($this->tags_id);

    }

    public function setTags($insert)
    {
        $this->tags_id = Tags::convertToString($insert);
    }


    public function is_in_this_radius($address, $radius)
    {

        $distance = self::getDistance($this->coords_x, $this->coords_y, $address->coords_x, $address->coords_y);

        if ($distance < $radius) return true;


    }


    public static function getDistance($lat1, $lon1, $lat2, $lon2)
    {
        $lat1 *= M_PI / 180;
        $lat2 *= M_PI / 180;
        $lon1 *= M_PI / 180;
        $lon2 *= M_PI / 180;

        $d_lon = $lon1 - $lon2;

        $slat1 = sin($lat1);
        $slat2 = sin($lat2);
        $clat1 = cos($lat1);
        $clat2 = cos($lat2);
        $sdelt = sin($d_lon);
        $cdelt = cos($d_lon);

        $y = pow($clat2 * $sdelt, 2) + pow($clat1 * $slat2 - $slat1 * $clat2 * $cdelt, 2);
        $x = $slat1 * $slat2 + $clat1 * $clat2 * $cdelt;

        return atan2(sqrt($y), $x) * 6372795;
    }

    public function getDistanceToObject($address)
    {
        $lat1 = $this->coords_y * M_PI / 180;
        $lat2 = $this->coords_x * M_PI / 180;
        $lon1 = $address->coords_y * M_PI / 180;
        $lon2 = $address->coords_x * M_PI / 180;

        $d_lon = $lon1 - $lon2;

        $slat1 = sin($lat1);
        $slat2 = sin($lat2);
        $clat1 = cos($lat1);
        $clat2 = cos($lat2);
        $sdelt = sin($d_lon);
        $cdelt = cos($d_lon);

        $y = pow($clat2 * $sdelt, 2) + pow($clat1 * $slat2 - $slat1 * $clat2 * $cdelt, 2);
        $x = $slat1 * $slat2 + $clat1 * $clat2 * $cdelt;

        return atan2(sqrt($y), $x) * 6372795;
    }

    function getNearestSameIdAddresses($radius, $count_of_years)
    {
        if ($this->house_type == 4) $this->house_type = 1;
        $same_addresses = Addresses::find()
            ->where(['locality' => $this->locality])
            ->andwhere(['<=', 'floorcount', $this->floorcount + 1])
            ->andwhere(['>=', 'floorcount', $this->floorcount - 1])
            ->andwhere(['house_type' => $this->house_type])
            ->andwhere(['>=', 'year', $this->year - $count_of_years])
            ->andwhere(['<=', 'year', $this->year + $count_of_years])
            ->andwhere(['in', 'precision_yandex', ['exact', 'number']])
            ->andwhere(['<>', 'id', $this->id])
            ->all();

        foreach ($same_addresses as $same_address) {

            if ($this->is_in_this_radius($same_address, $radius)) {
                //  echo "<br> данный адрес похохий адрес ".$same_address->address." ".$same_address->year." - на расстоянии ".$address->getDistance($address->coords_x,$address->coords_y,$same_address->coords_x,$same_address->coords_y) ." метров.";
                $id_addresses[] = $same_address->id;
            }


        }
        return $id_addresses;

    }

    // возвращает, что адрес имеет все параметры 
    public function isFull()
    {
        // if ($this->status == 2) return true;
        if ((!$this->year) or (!$this->floorcount) or (!$this->house_type))
            return false;
        else return true;

    }


    // метод для импортирования недостающих параметров 
    public function update_from_sale($sale)
    {
        $log = '';
        if (($sale->year) and (!$this->year)) {
            $this->year = $sale->year;
            $log .= "export " . span("year=" . $this->year) . " from sale to address<br>";
        }
        if (($sale->floorcount) and (!$this->floorcount)) {
            $this->floorcount = $sale->floorcount;
            $log .= "export " . span("floorcount=" . $this->floorcount) . " from sale to address<br>";
        }
        if (($sale->house_type) and (!$this->house_type)) {
            $this->house_type = $sale->house_type;
            $log .= "export " . span("house_type=" . $this->house_type) . " from sale to address<br>";
        }
        return $log;
    }

    // метод для экспортирования недостающих параметров
    public function update_to_sale($sale)
    {
        $log = '';
        // $sale->address = $this->address;
        $sale->id_address = $this->id;
        // эти параметры подтягиваем из связи sale->addresses

        $sale->locality = $this->locality;
//        // если годы не совпадают то
//        if ($sale->year != $this->year) {
//            $sale->year = $this->year;
//            $log .= "export ".span("year=".$this->year)." from address<br>";
//        }
//        if ($sale->house_type != $this->house_type) {
//            $sale->house_type = $this->house_type;
//            $log .= "export ".span("house_type=".$this->house_type)." from address<br>";
//        }
//        if ($sale->floorcount != $this->floorcount) {
//            $sale->floorcount = $this->floorcount;
//            $log .= "export ".span("floorcount=".$this->floorcount)." from address<br>";
//        }

        // $sale->coords_x = $address->coords_x;
        // $sale->coords_y = $address->coords_y;


        return $log;
    }

    public function getPattern()
    {
        // выбираем последнее слово из вариантов улиц и отрезаем последнюю букву т.к. могут ввести Петербургская124 без пробела
        // в итоге ("б. Санкт-Петербургская" выберется "Петербургска"

        $last_variant_name_of_street = str_replace("\\|\/", "u", mb_substr(array_pop(preg_split('/\s|-/', $this->street)), 0, -1));
        // TODO Добавили эту строчку
        if ($last_variant_name_of_street == '') return false;
        if (strpos($this->street, 'ё')) $last_variant_name_of_street = str_replace('ё', '(е|ё)', $last_variant_name_of_street);
        // сначала осущеcтвляем поиск с корпусами
        if ($this->hull == '-') {
            //  echo "<br>" . gettype($this->hull) . $this->hull;
           // $pattern = "/" . mb_strtolower($last_variant_name_of_street) . "+\D{1,20}" . $this->house . "+\D/";
            $pattern = "/" . mb_strtolower($last_variant_name_of_street) . "+\D{1,20}" . $this->house . "/";
        } else $pattern = "/" . mb_strtolower($last_variant_name_of_street) . "+\D{1,20}" . $this->house . "+\D{1,15}" . $this->hull . "/";
        return $pattern;
    }


    public function try_to_find_house_type()
    {
        // ищем в истории где есть эта этажность
        $sale_history = SaleHistory::find()
            ->andWhere(['id_address' => $this->id])
            ->andWhere(['in', 'house_type', [1, 2, 3, 4, 5]])
            ->one();
        if (!empty($sale_history->id)) {
            // вставляем значение в таблицу адресов
            $UpdatedAddress = Addresses::findOne($this->id);
            echo "удалось прописать house_type " . $UpdatedAddress->id . "  = " . $sale_history->house_type;
            $UpdatedAddress->house_type = $sale_history->house_type;
            $UpdatedAddress->save();
        } else {
            $sale_history = Sale::find()
                ->andWhere(['id_address' => $this->id])
                ->andWhere(['in', 'house_type', [1, 2, 3, 4, 5]])
                ->one();
            if (!empty($sale_history->id)) {
                // вставляем значение в таблицу адресов
                $UpdatedAddress = Addresses::findOne($this->id);
                echo "удалось прописать house_type " . $UpdatedAddress->id . "  = " . $sale_history->house_type;
                $UpdatedAddress->house_type = $sale_history->house_type;
                $UpdatedAddress->save();
            }

        }


    }

    public function try_to_find_year_non_description()
    {
        // ищем в истории где есть эта этажность
        $sale_history = SaleHistory::find()
            ->andWhere(['id_address' => $this->id])
            ->andWhere(['<>', 'year', 0])
            ->andWhere(['<>', 'year', null])
            ->one();

        if (!empty($sale_history->id)) {
            // вставляем значение в таблицу адресов
            $UpdatedAddress = Addresses::findOne($this->id);
            echo "удалось прописать house_type " . $UpdatedAddress->id . "  = " . $sale_history->year;
            $UpdatedAddress->year = $sale_history->year;
            $UpdatedAddress->save();
        } else {
            $sale_history = Sale::find()
                ->andWhere(['id_address' => $this->id])
                ->andWhere(['<>', 'year', 0])
                ->andWhere(['<>', 'year', null])
                ->one();
            if (!empty($sale_history->id)) {
                // вставляем значение в таблицу адресов
                $UpdatedAddress = Addresses::findOne($this->id);
                echo "удалось прописать house_type " . $UpdatedAddress->id . "  = " . $sale_history->year;
                $UpdatedAddress->year = $sale_history->year;
                $UpdatedAddress->save();
            }

        }


    }

    public function try_to_find_year()
    {
        $edit_sales_history = SaleHistory::find()
            ->select('description')
            ->where(['id_address' => $this->id])
            ->all();
        foreach ($edit_sales_history as $edit_sale_history) {

            if (preg_match_all('/[1,2][9,0]\d\d/', $edit_sale_history->description, $matches)) {

                foreach ($matches[0] as $item) {

                    $ajax_button = "<button class=\"btn btn-success btn-xs set-year-and-fix-it\"
                                data-id_address=\"$this->id\"
                                data-year=\"$item\">$item</button>";
                    $message = "<b>" . $ajax_button . "</b> in ";

                    if (in_array($item, range(1950, 2018))) {
                        $strpos = strpos($edit_sale_history->description, $item);
                        $hilighted_str_start = substr($edit_sale_history->description, $strpos - 45, 45);
                        $hilighted_str_end = substr($edit_sale_history->description, $strpos + 4, 45);
                        $message .= $hilighted_str_start . "<b>" . $item . "</b>" . $hilighted_str_end . " - ";
                        $response = [
                            'message' => $message,
                            'year' => $item
                        ];

                        return $response;
                    } else return [
                        'message' => '',
                        'year' => 0
                    ];

                }
            }

        }


    }

    public function try_to_find_house_type_in_description()
    {
        $edit_sales_history = SaleHistory::find()
            ->select('description')
            ->where(['id_address' => $this->id])
            ->all();
        foreach ($edit_sales_history as $edit_sale_history) {
            $message .= $edit_sale_history->description . "<br>";


        }


    }

    public function try_to_find_floorcount_in_description()
    {
        $edit_sales_history = SaleHistory::find()
            ->select('description')
            ->where(['id_address' => $this->id])
            ->limit(10)
            ->all();
        // $message  = '';
        foreach ($edit_sales_history as $edit_sale_history) {
            $message .= $edit_sale_history->description . "<br>";

        }

        return $message;


    }

    public function set_year($year)
    {
        $address = self::findOne($this->id);
        $address->year = $year;
        $address->save();

    }

    public function set_floorcount($floorcount)
    {
        $address = self::findOne($this->id);
        $address->year = $floorcount;
        $address->save();

    }

    public function set_house_type($house_type)
    {
        $address = self::findOne($this->id);
        $address->year = $house_type;
        $address->save();

    }

    public function RenderHouseType($type = 'short')
    {
        if ($type == 'short') {
            if ($this->house_type == 1) $string = 'Пан';
            if ($this->house_type == 2) $string = 'Кирп.';
            if ($this->house_type == 3) $string = 'Мон.';
            if ($this->house_type == 4) $string = 'Бл.';
            if ($this->house_type == 5) $string = 'Дер.';
        } else {
            if ($this->house_type == 1) $string = 'Панельный';
            if ($this->house_type == 2) $string = 'Кирпичный';
            if ($this->house_type == 3) $string = 'Монолитный';
            if ($this->house_type == 4) $string = 'Блочный';
            if ($this->house_type == 5) $string = 'Деревянный';

        }


        return $string;
    }

    public function Fix()
    {
        $this->status = 1;
        if (!$this->save()) var_dump($this->errors);

    }


}
